#![allow(dead_code, unused_variables)]
#![feature(heap_api, alloc)]
extern crate rustc_serialize;
extern crate docopt;

mod script;
mod vm;
mod default_opcodes;

use default_opcodes::DefaultOpcodes;
use docopt::Docopt;

#[derive(RustcDecodable)]
struct Args {
    arg_name: String,
    arg_bytecode: String
}

fn main() {
    /*//let bytecode: Vec<u8> = vec![0x00, 0x00, 0x03, 0x00, 0x03, 0x01, 0x00, 0x04, 0x05, 0x0A, 0x00, 0x03, 0x01, 0x00, 0x04, 0x00, 0x03, 0x01, 0x00, 0x04, 0x05, 0x0A, 0x00, 0x03, 0x01, 0x00, 0x05, 0x00, 0x03, 0x01, 0x00, 0x04, 0x01, 0x0A, 0x00, 0x03, 0x01, 0x00, 0x06, 0x00, 0x03, 0x01, 0x00, 0x04, 0x04, 0x0A, 0x00, 0x03, 0x01, 0x00, 0x07, 0x00, 0x03, 0x01, 0x00, 0x04, 0x04, 0x0A, 0x00, 0x03, 0x01, 0x00];
    //let bytecode: Vec<u8> = vec![0x00, 0x00, 0x03, 0x00, 0x03, 0x01, 0x00, 0x04, 0x05, 0x0A, 0x00, 0x03, 0x01, 0x00, 0x0E, 0x00, 0x01, 0xCF, 0xFF, 0xFF, 0xFF, 0x04, 0x02, 0x03, 0x01, 0x00, 0x04, 0x0A, 0x03, 0x02, 0x00, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x00, 0x0A, 0x00, 0x03, 0x02, 0x00, 0x02, 0x00, 0x01, 0xF7, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x03, 0x19, 0x00, 0x03, 0x00, 0x00, 0x04, 0x00, 0x03, 0x19, 0x00, 0x03, 0x01, 0x00, 0x0E, 0x00, 0x01, 0xAA, 0xFF, 0xFF, 0xFF, 0x04, 0x01, 0x03, 0x19, 0x00, 0x00, 0x0F, 0x00, 0x04, 0x01, 0x03, 0x19, 0x00, 0x00, 0x0A, 0x00, 0x03, 0x00, 0x00, 0x0F, 0x00, 0x04, 0x00, 0x00];
    let bytecode: Vec<u8> = vec![0x00, 0x00, 0x03, 0x00, 0x03, 0x01, 0x00, 0x0E, 0x11, 0x48, 0x45, 0x4C, 0x4C, 0x4F, 0x57, 0x20, 0x4D, 0x59, 0x20, 0x46, 0x52, 0x49, 0x45, 0x4E, 0x44, 0x21, 0x0A, 0x00, 0x03, 0x01, 0x00];
    let mut vm = vm::VirtualMachine::new();
    
    vm.append_script("test".to_string(), bytecode);
    vm.set_default_opcodes();
    
    loop {
        vm.tick();
    }*/

    let usage = "Usage: cleovm <name> <bytecode>";
    let args: Args = Docopt::new(usage)
                        .and_then(|d| d.argv(std::env::args()).decode())
                        .unwrap_or_else(|e| e.exit());

    //println!("{}, {}", args.arg_name, args.arg_bytecode);
    let bytecode = text_to_bytes(&args.arg_bytecode);
    

    let mut vm = vm::VirtualMachine::new();

    // .\cleovm.exe "test" "000003000301000E1148454C4C4F57204D5920465249454E44210A00030100"

    vm.append_script(args.arg_name.clone(), bytecode);
    vm.set_default_opcodes();

    while !vm.is_done(args.arg_name.clone()) {
        vm.tick();
    }
}

fn text_to_bytes(text: &String) -> Vec<u8> {
    let mut i = 0;
    let mut bytes: Vec<u8> = Vec::new();

    while i < text.len() {
        let byte = &text[i..i+2];
        bytes.push(parse_byte(&byte));
        i += 2;
    }

    return bytes;
}

fn parse_byte(text: &str) -> u8 {
    let mut value = 0;
    let mut idx = 1;

    for byte in text.bytes() {
        let half = match byte {
            b'0'...b'9' => byte - b'0',
            b'A'...b'F' => byte - b'A' + 10,
            _ => panic!("fuck gg"),
        };

        value += half << (4 * idx);

        idx -= 1;
    }

    return value;
}